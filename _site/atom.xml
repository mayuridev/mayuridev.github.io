<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>The Haven</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2020-07-22T08:58:05-07:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>Access=0000</title>
   <link href="http://localhost:4000/2020/07/17/Access=0000/"/>
   <updated>2020-07-17T00:00:00-07:00</updated>
   <id>http://localhost:4000/2020/07/17/Access=0000</id>
   <content type="html">&lt;p&gt;This was a writeup for a crypto challenge in &lt;a href=&quot;https://ractf.co.uk/&quot;&gt;RACTF&lt;/a&gt; 2020, where &lt;a href=&quot;https://rgbsec.xyz&quot;&gt;we&lt;/a&gt; placed 6th.&lt;/p&gt;

&lt;h3 id=&quot;challenge-description&quot;&gt;Challenge Description:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Challenge instance ready at 95.216.233.106:57735

We found a strange service, it looks like you can generate an access token for the network service, but you shouldn't be able to read the flag... We think.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;solving-&quot;&gt;Solving :&lt;/h3&gt;

&lt;p&gt;We are given &lt;a href=&quot;https://pastebin.com/3e9ryfvf&quot;&gt;access.py&lt;/a&gt;. Lets take a look the server file to see what the program does.&lt;/p&gt;

&lt;p&gt;From the top, we see that &lt;code class=&quot;highlighter-rouge&quot;&gt;get_flag&lt;/code&gt;: 
&lt;!--more--&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def get_flag(token, iv):
    token = bytes.fromhex(token)
    iv = bytes.fromhex(iv)
    try:
        cipher = AES.new(KEY, AES.MODE_CBC, iv)
        decrypted = cipher.decrypt(token)
        unpadded = unpad(decrypted, 16)
    except ValueError as e:
        return {&quot;error&quot;: str(e)}
    if b&quot;access=0000&quot; in unpadded:
        return {&quot;flag&quot;: FLAG}
    else:
        return {&quot;error&quot;: &quot;not authorized to read flag&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1) converts &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;iv&lt;/code&gt; to their representation as “bytes”&lt;/p&gt;

&lt;p&gt;2) tries to decrypt &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt; with the given &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;iv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3) if the string &lt;code class=&quot;highlighter-rouge&quot;&gt;access=0000&lt;/code&gt; is in the message, then it will return the flag&lt;/p&gt;

&lt;p&gt;4) if the string &lt;code class=&quot;highlighter-rouge&quot;&gt;access=0000&lt;/code&gt; is not in the message, else print &lt;code class=&quot;highlighter-rouge&quot;&gt;not authorized to read flag&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Below that is &lt;code class=&quot;highlighter-rouge&quot;&gt;generate_token&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def generate_token():
    expires_at = (datetime.today() + timedelta(days=1)).strftime(&quot;%s&quot;)
    token = f&quot;access=9999;expiry={expires_at}&quot;.encode()
    iv = get_random_bytes(16)
    padded = pad(token, 16)
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    encrypted = cipher.encrypt(padded)
    ciphertext = iv.hex() + encrypted.hex()
    return {&quot;token&quot;: ciphertext}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1) creates an expiration date&lt;/p&gt;

&lt;p&gt;2) generates a token string with &lt;code class=&quot;highlighter-rouge&quot;&gt;access=9999&lt;/code&gt; (defined with guest + token expire time)&lt;/p&gt;

&lt;p&gt;3) generates a random &lt;code class=&quot;highlighter-rouge&quot;&gt;iv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4) pads &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt; to the AES block size&lt;/p&gt;

&lt;p&gt;5) creates a new AES cipher instance&lt;/p&gt;

&lt;p&gt;6) encrypts the padded &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;7) generates the cipher text as a result of &lt;code class=&quot;highlighter-rouge&quot;&gt;iv.hex()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;encrypted.hex()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;8) returns the ciphertext&lt;/p&gt;

&lt;p&gt;As we can see, the goal of this challenge  is to retrieve the flag by generating a guest token = &lt;code class=&quot;highlighter-rouge&quot;&gt;access=9999&lt;/code&gt; and forge an admin token = &lt;code class=&quot;highlighter-rouge&quot;&gt;access=0000&lt;/code&gt;. As we can see from &lt;code class=&quot;highlighter-rouge&quot;&gt;generate_token()&lt;/code&gt;, guest tokens are generatated with an AES-CBC mode encryption of &lt;code class=&quot;highlighter-rouge&quot;&gt;access=9999;expiry={expires_at}&lt;/code&gt;. In the AES-CBC mode, the stream is split into 16-byte blocks, with each block encrypted with AES. Then the result is sent to output and XORed with the next block before it gets encrypted.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/CBC_encryption.svg/1920px-CBC_encryption.svg.png&quot; alt=&quot;Here is a depiction of CBC mode encryption.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The ciphertext (the result of the encryption) is = &lt;code class=&quot;highlighter-rouge&quot;&gt;c[i] = AES_Enc(c[i-1] XOR m[i])&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;c[0]&lt;/code&gt; being &lt;code class=&quot;highlighter-rouge&quot;&gt;iv&lt;/code&gt;. If we want to decrypt the ciphertext, we can use the following formula = &lt;code class=&quot;highlighter-rouge&quot;&gt;m[i] = AES_Dec(c[i]) XOR c[i-1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;solve-script-&quot;&gt;Solve Script :&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;token = '3913er43j134h6d4fk81df97h4812df315dfd978g62fuehf38173g7eba445g9833kj1371637h26hfa3khuy3j5vx948d0'
token = bytes.fromhex(token)

iv = token[:16]
ct = token[16:]

for i in range(7,11):
    iv = iv[:i] + bytes([(iv[i] ^ ord('0') ^ ord('9'))]) + iv[i+1:]

print(iv.hex())
print(ct.hex())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This script replaces &lt;code class=&quot;highlighter-rouge&quot;&gt;iv&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;iv XOR D&lt;/code&gt;, so the first block of the plaintext will be decoded as &lt;code class=&quot;highlighter-rouge&quot;&gt;m[0] XOR D&lt;/code&gt;. We can XOR our &lt;code class=&quot;highlighter-rouge&quot;&gt;iv&lt;/code&gt; to change the guest token (&lt;code class=&quot;highlighter-rouge&quot;&gt;access=9999&lt;/code&gt;) to the admin token (&lt;code class=&quot;highlighter-rouge&quot;&gt;access=0000&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Flag: &lt;strong&gt;ractf{cbc_b17_fl1pp1n6_F7W!}&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Really Smart Acronym</title>
   <link href="http://localhost:4000/2020/07/16/Really-Smart-Acronym/"/>
   <updated>2020-07-16T00:00:00-07:00</updated>
   <id>http://localhost:4000/2020/07/16/Really Smart Acronym</id>
   <content type="html">&lt;h3 id=&quot;challenge-description&quot;&gt;Challenge Description:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Man, oracles are weird.

nc challenges1.hexionteam.com 5000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solving-&quot;&gt;&lt;strong&gt;Solving :&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;​Really Smart Acronym, of course, is RSA. Looking at the code, it uses PyCrypto to generate a RSA key to encrypt the flag. You also get one encryption and 1024 decrypts, but you only get the last bit of the decrypts. At first we thought it could be Franklin-Reiter related-message attack, but there is not enough information for that.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack&quot;&gt;This thread&lt;/a&gt; was one of the resources that we used to solve this problem. From there, the method is given, but we still need to find e and N for the attack to work. e is easy. Since it uses PyCrypto, &lt;code class=&quot;highlighter-rouge&quot;&gt;e = 65537&lt;/code&gt;. As for N, that’s what the one encrypt is for. If you realize you can pass negative numbers for the encrypt, then it becomes easy. The encrypted message is &lt;code class=&quot;highlighter-rouge&quot;&gt;m^e mod N&lt;/code&gt;, so if you pass &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;, it becomes &lt;code class=&quot;highlighter-rouge&quot;&gt;-1^65537 mod N = N – 1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;solve-script-&quot;&gt;&lt;strong&gt;Solve Script :&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from pwn import *

sh = remote('challenges1.hexionteam.com', 5000)

sh.recvuntil('Flag: ')

cipher = int(sh.recvline().decode().strip())
#print(cipher)

sh.recvuntil('m =&amp;gt; ')
sh.sendline('-1')

n = int(sh.recvline().decode().strip()) + 1

mult = pow(2, 65537, n)
#print(mult)

def get_lsb(num):
	sh.recvuntil('&amp;gt; ')
	sh.sendline(str(num))
	return int(sh.recvline().decode().strip())

high = n
low = 0
for i in range(1024):
	cipher *= mult
	cipher %= n
	lsb = get_lsb(cipher)
	if lsb == 0:
		high = (high + low) // 2
	else:
		low = (high + low) // 2

print(high)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Flag: &lt;strong&gt;hexCTF{n1c3_r5a_tr1ck5_m4t3}&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>S.S.S.</title>
   <link href="http://localhost:4000/2020/07/15/SSS/"/>
   <updated>2020-07-15T00:00:00-07:00</updated>
   <id>http://localhost:4000/2020/07/15/SSS</id>
   <content type="html">&lt;p&gt;This is a writeup for HexionCTF 2020, where &lt;a href=&quot;https://rgbsec.xyz&quot;&gt;we&lt;/a&gt; placed third.&lt;/p&gt;

&lt;h3 id=&quot;challenge-description&quot;&gt;Challenge Description:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Math is so beautiful and can always be used for cryptographic
encryption!
nc challenges1.hexionteam.com 5001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solving-&quot;&gt;Solving :&lt;/h3&gt;

&lt;p&gt;We are given an sss.py. See &lt;a href=&quot;https://pastebin.com/uYwhAUcX&quot;&gt;here&lt;/a&gt; for source.&lt;/p&gt;

&lt;p&gt;We found that SSS stands for Shamir’s Secret Sharing by copy-pasting the loop from &lt;code class=&quot;highlighter-rouge&quot;&gt;eval_at&lt;/code&gt;, which brought me to &lt;a href=&quot;https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing&quot;&gt;this&lt;/a&gt; Wikipedia Page. Shamir Secret Sharing is based on polynomials and lagrange interpolation.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Most of this code (nearly everything except main) is taken from Wikipedia’s example implementation of Shamir’s Secret Sharing. The concept is relatively simple. The sss.py that we are given is giving out “shares”, with the flag as the secret. We can just request enough shares until we meet the minimum threshold to be able to recover the secret. From there, we can use langrage interpolation to calculate y for x=0 and retrieve our flag.&lt;/p&gt;

&lt;h3 id=&quot;solve-script-&quot;&gt;Solve Script :&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from Crypto.Util.number import long_to_bytes
from pwn import remote
 
P = 2 ** 521 - 1
 
 
def eval_at(poly, x, prime):
    accum = 0
    for coeff in reversed(poly):
        accum *= x
        accum += coeff
        accum %= prime
    return accum
 
 
def extended_gcd(a, b):
    x = 0
    last_x = 1
    y = 1
    last_y = 0
    while b != 0:
        quot = a // b
        a, b = b, a % b
        x, last_x = last_x - quot * x, x
        y, last_y = last_y - quot * y, y
    return last_x, last_y
 
 
def divmod(num, den, p):
    inv, _ = extended_gcd(den, p)
    return num * inv
 
 
def _lagrange_interpolate(x, x_s, y_s, p):
    k = len(x_s)
    assert k == len(set(x_s)), &quot;points must be distinct&quot;
 
    def PI(vals):  # product of inputs
        accum = 1
        for v in vals:
            accum *= v
        return accum
 
    nums = []
    dens = []
    for i in range(k):
        others = list(x_s)
        cur = others.pop(i)
        nums.append(PI(x - o for o in others))
        dens.append(PI(cur - o for o in others))
    den = PI(dens)
    num = sum([divmod(nums[i] * den * y_s[i] % p, dens[i], p)
               for i in range(k)])
    return (divmod(num, den, p) + p) % p
 
 
def recover_secret(shares, prime=P):
    x_s, y_s = zip(*shares)
    return _lagrange_interpolate(0, x_s, y_s, prime)
 
 
def main():
    # connect to the nc server
    r = remote(&quot;challenges1.hexionteam.com&quot;, 5001)
    r.recvuntil(&quot;&amp;gt;&amp;gt;&amp;gt;&quot;)
    shares = []
 
    # request 78 shares, just to be safe (min is a random int between 48 and 63, inclusive)
    for i in range(0x1, 0x50):
        if i == ord('\n'):  
            continue
        r.sendline(long_to_bytes(i))
        resp = r.recvline().decode()
        resp = resp.strip().strip('&amp;gt;').strip()
        shares.append((i,int(resp)))
 
        if len(shares) % 5 == 0:
            print(&quot;Acquired&quot;, len(shares), &quot;shares&quot;)
 
    # print(shares)
    print(long_to_bytes(recover_secret(shares)))
 
 
if __name__ == '__main__':
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Flag : &lt;strong&gt;hexCTF{d0nt_us3_shar3s_lik3_that}&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World!</title>
   <link href="http://localhost:4000/2020/07/15/Hello-World!/"/>
   <updated>2020-07-15T00:00:00-07:00</updated>
   <id>http://localhost:4000/2020/07/15/Hello World!</id>
   <content type="html">&lt;p&gt;During quarantine, I decided to make a blog (The Haven) to journal my thoughts and experiences.&lt;/p&gt;

&lt;p&gt;Happy Reading!&lt;/p&gt;

&lt;p&gt;Sincerely,&lt;/p&gt;

&lt;p&gt;Dylan&lt;/p&gt;
</content>
 </entry>
 

</feed>
